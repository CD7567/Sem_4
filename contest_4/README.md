## Contest_4

### A_Треугольный_генератор_Паскаля

Напишите генератор, возвращающий бесконечную последовательность чисел из треугольника Паскаля.

Сдавать нужно только код самого генератора, тестирующий код импортирует его и прогонит набор тестов.

Последовательность, возвращаемая генератором, должна выглядеть так:
1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 ...

Требуется реализовать генератор в виде функции без аргументов с именем pascal_triangle.

Текст програмы должен содержать генератор pascal_triangle и все необходимые импорты.

### B_Сливаемся!

Напишите генератор, выполняющий слияние отсортированных последовательностей целых чисел.

Сдавать нужно только код самого генератора, тестирующий код импортирует его и прогонит набор тестов.

Генератор принимает произвольное число аргументов. Аргументом может быть любой итерируемый объект, в том числе другой генератор. Гарантируется, что каждый аргумент — это последовательность целых чисел, отсортированных в порядке неубывания.

Текст программы должен содержать генератор с именем merge_sorter и все необходимые импорты.

### С_Декоратор_проверки_аргументов

Напишите декоратор @takes, который будет проверять правильность типов входных аргументов функции.

Декоратор принимает на вход типы аргументов и декорирует функцию таким образом, что она генеририрует исключение TypeError, если хотя бы один из аргументов имеет неверный тип.

Если аргументов больше, чем типов, то ошибку генерировать не нужно (возможно, точный тип известен только для первых аргументов, его, как раз, надо проверить).

Если типов больше, чем аргументов, то это тоже ошибка только в случае, если переданные аргументы не подходят под соответствующие им по порядку типы. (декоратор может быть применен к функциям с переменным числом аргументов).

Декоратор должен вести себя порядочно, то есть не должен затирать основные аргументы функции (__name__, __doc__, __module__).

Для простоты можно считать, что у функции нет именованных аргументов.

Генерацию исключений воспринимайте пока как волшебный способ просигнализировать об ошибке. Делается это так: raise TypeError

### D_LRU_cache_decorator

Бывает полезно оптимизировать вызовы "тяжёлых"функций с помощью кеширования. Кеширование – это сохранение результатов выполнения функций для предотвращения повторных вычислений. Перед вызовом функции проверяется есть ли уже вычисленный результат. Если есть – функция не вызывается, а возвращается сохранённое значение.

Реализуйте декоратор для Least Recently Used (LRU) Cache. Пользователь указывает размер кеша N, и в кеше сохраняются N последних вычислений. Другими словами, вытесняется из кеша сначало то, что использовалось давней всего.

Декоратор назовите @cache, он должен принимать один параметр – размер кеша. Поддержите как можно более широкий класс функций (функции многих аргументов, функции с именоваными параметрами, принимающие сложные типы итд). Декоратор должен вести себя порядочно, то есть не должен затирать документацию функции.

### E_Профилятор

Напишите декоратор @proﬁler, который при вызове функции будет сохранять в её атрибуты время ее исполнения (в секундах, можно дробное) и количество рекурсивных вызовов, произошедших при исполнении. Атрибуты назовите last_time_taken и calls.

Пользоваться глобальными переменными запрещено.
Декоратор должен вести себя порядочно, то есть не должен затирать документацию функции.

Сдавать нужно только код самого декоратора, тестирующий код импортирует его и прогонит набор тестов. Тестирующий код импортирует из вашего модуля декоратор и прогонит на наборе тестов.